# -*- coding: utf-8 -*-
"""ftp_to_drive.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_9zry86msG3Kl-eeDZanNm7uHuY3GQ8U
"""

!pip install --upgrade google-api-python-client google-auth-httplib2 google-auth-oauthlib --quiet

import os.path
import mimetypes # Para adivinhar o tipo MIME do arquivo
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from googleapiclient.http import MediaFileUpload

# Se modificar esses escopos, delete o arquivo token.json.
SCOPES = ['https://www.googleapis.com/auth/drive'] # Escopo completo para Drive
# SCOPES = ['https://www.googleapis.com/auth/drive.file'] # Escopo para arquivos criados pelo app

TOKEN_FILE = '/content/drive/MyDrive/Projetos/eCarta_Connect/Credenciais/token.json'
CREDENTIALS_FILE = '/content/drive/MyDrive/Projetos/eCarta_Connect/Credenciais/credentials.json' # Arquivo baixado do Google Cloud Console

def get_drive_service():
    """Mostra o fluxo de login e cria o serviço da API do Drive."""
    creds = None
    # O arquivo token.json armazena os tokens de acesso e atualização do usuário,
    # e é criado automaticamente na primeira vez que o fluxo de autorização é completado.
    if os.path.exists(TOKEN_FILE):
        creds = Credentials.from_authorized_user_file(TOKEN_FILE, SCOPES)
    # Se não houver credenciais válidas disponíveis, deixe o usuário fazer login.
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file(
                CREDENTIALS_FILE, SCOPES)
            # Certifique-se de que o servidor de redirecionamento pode ser iniciado.
            # Tente uma porta diferente se a padrão (8080) estiver em uso.
            # Você pode especificar a porta assim: flow.run_local_server(port=8081)
            creds = flow.run_local_server(port=0) # port=0 escolhe uma porta livre
        # Salve as credenciais para a próxima execução
        with open(TOKEN_FILE, 'w') as token:
            token.write(creds.to_json())

    try:
        service = build('drive', 'v3', credentials=creds)
        return service
    except HttpError as error:
        print(f'Um erro ocorreu ao construir o serviço: {error}')
        return None

def upload_file_to_folder(service, local_file_path, folder_id, drive_filename=None):
    """Faz upload de um arquivo para uma pasta específica no Google Drive.
    Args:
        service: Objeto de serviço da API do Google Drive autorizado.
        local_file_path: Caminho para o arquivo local a ser enviado.
        folder_id: ID da pasta do Google Drive onde o arquivo será salvo.
        drive_filename: Nome que o arquivo terá no Google Drive (opcional, usa o nome local se None).
    Returns:
        ID do arquivo criado no Drive, ou None se falhar.
    """
    if not os.path.exists(local_file_path):
        print(f"Arquivo local não encontrado: {local_file_path}")
        return None

    if drive_filename is None:
        drive_filename = os.path.basename(local_file_path)

    # Adivinha o tipo MIME do arquivo
    mimetype, _ = mimetypes.guess_type(local_file_path)
    if mimetype is None:
        mimetype = 'application/octet-stream' # Tipo genérico se não puder adivinhar

    file_metadata = {
        'name': drive_filename,
        'parents': [folder_id]  # Especifica a pasta pai
    }
    media = MediaFileUpload(local_file_path,
                            mimetype=mimetype,
                            resumable=True)
    try:
        file = service.files().create(body=file_metadata,
                                      media_body=media,
                                      fields='id, name, webViewLink').execute() # Adicionado webViewLink
        print(f"Arquivo '{file.get('name')}' enviado com sucesso!")
        print(f"ID do Arquivo: {file.get('id')}")
        print(f"Link do Arquivo: {file.get('webViewLink')}")
        return file.get('id')
    except HttpError as error:
        print(f'Um erro ocorreu durante o upload: {error}')
        return None

from ftplib import FTP
import zipfile
import os
from os.path import isdir, isfile, join

# Configurações
host = "ediac.correios.com.br"
port = 21  # Use 990 para FTPS
usuario = "563793"
senha = "ryj537@3>"
directory = "/E-carta"
downloads_folder = "/content/downloads"  # Pasta local no Colab
uploads_folder = "/content/uploads"  # Pasta local no Colab
files_folder = "/content/files"  # Pasta local no Colab

os.makedirs(downloads_folder, exist_ok=True)
os.makedirs(uploads_folder, exist_ok=True)
os.makedirs(files_folder, exist_ok=True)

#DOWNLOAD ARQUIVOS

try:
    ftp = FTP()
    ftp.connect(host, port)
    ftp.login(usuario, senha)

    ftp.cwd(directory)

    files = ftp.nlst()  # Obtém a lista de arquivos no diretório
    files_to_download = [file for file in files if not ('Recibo' in file or 'Inconsistencia' in file or 'DevolucaoAR' in file)]

    # for f in files_to_download:
    #   print(f)

    #print(f"Arquivos encontrados no diretório {directory}: {files}")

    #Baixando cada arquivo
    for file in files_to_download:
        local_file_path = os.path.join(downloads_folder, file)
        with open(local_file_path, "wb") as local_file:
            #print(f"Baixando {file}...")
            ftp.retrbinary(f"RETR {file}", local_file.write)
        print(f"{file} baixado com sucesso para {local_file_path}.")

    ftp.quit()

except Exception as e:
    print(f"Erro: {e}")

import zipfile
import os
import shutil # Para criar um zip de exemplo e limpar

def descompactar_zip(caminho_arquivo_zip, pasta_destino):
    """
    Descompacta um arquivo ZIP para uma pasta de destino especificada.

    Args:
        caminho_arquivo_zip (str): O caminho completo para o arquivo .zip.
        pasta_destino (str): O caminho para a pasta onde os arquivos serão extraídos.
                             Se a pasta não existir, ela será criada.

    Returns:
        bool: True se a descompactação for bem-sucedida, False caso contrário.
    """
    # 1. Verificar se o arquivo ZIP existe
    if not os.path.exists(caminho_arquivo_zip):
        print(f"Erro: Arquivo ZIP não encontrado em '{caminho_arquivo_zip}'")
        return False

    # 2. Verificar se o arquivo é realmente um ZIP (opcional, mas bom)
    if not zipfile.is_zipfile(caminho_arquivo_zip):
        print(f"Erro: O arquivo '{caminho_arquivo_zip}' não parece ser um arquivo ZIP válido.")
        return False

    # 3. Criar a pasta de destino se ela não existir
    try:
        # os.makedirs cria diretórios pais se necessário
        # exist_ok=True não levanta erro se o diretório já existir
        os.makedirs(pasta_destino, exist_ok=True)
        print(f"Pasta de destino '{pasta_destino}' assegurada/criada.")
    except OSError as e:
        print(f"Erro ao criar a pasta de destino '{pasta_destino}': {e}")
        return False

    # 4. Descompactar o arquivo
    try:
        with zipfile.ZipFile(caminho_arquivo_zip, 'r') as zip_ref:
            print(f"Descompactando '{os.path.basename(caminho_arquivo_zip)}' para '{pasta_destino}'...")
            zip_ref.extractall(pasta_destino)
            print("Descompactação concluída com sucesso.")
            # Opcional: listar os arquivos extraídos
            # print("Arquivos extraídos:")
            # for nome_arquivo in zip_ref.namelist():
            #     print(f"  - {nome_arquivo}")
            return True
    except zipfile.BadZipFile:
        print(f"Erro: Arquivo ZIP corrompido ou inválido: '{caminho_arquivo_zip}'")
        return False
    except Exception as e:
        print(f"Um erro inesperado ocorreu durante a descompactação: {e}")
        return False

for root, dirs, files in os.walk(downloads_folder):
    for file in files:
      descompactar_zip(f'/content/downloads/{file}', files_folder)

import os
import mimetypes
from google.colab import auth # Importar o módulo de autenticação do Colab
from google.auth import default # Para obter as credenciais padrão após a autenticação
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from googleapiclient.http import MediaFileUpload

# Se modificar esses escopos, pode ser necessário reautenticar.
SCOPES = ['https://www.googleapis.com/auth/drive']

# No Colab, não vamos usar token.json ou credentials.json diretamente desta forma
# TOKEN_FILE = 'token.json'
# CREDENTIALS_FILE = 'credentials.json' # O projeto Cloud ainda precisa ser configurado!

def get_drive_service_colab():
    """Autentica o usuário no Colab e cria o serviço da API do Drive."""
    try:
        # 1. Autenticar o usuário no Colab. Isso abrirá um pop-up.
        auth.authenticate_user()
        print("Usuário autenticado no Colab.")

        # 2. Obter as credenciais padrão do ambiente Colab após a autenticação.
        creds, _ = default()
        print("Credenciais obtidas.")

        # Opcional: Verificar validade e refresh, embora Colab geralmente lide bem com isso.
        # from google.auth.transport.requests import Request
        # if not creds or not creds.valid:
        #     if creds and creds.expired and creds.refresh_token:
        #         print("Atualizando credenciais...")
        #         creds.refresh(Request())
        #     else:
        #         # Se chegou aqui, algo fundamental falhou com a autenticação do Colab.
        #         print("Falha ao obter credenciais válidas no Colab após authenticate_user.")
        #         return None

        # 3. Construir o serviço da API do Drive.
        service = build('drive', 'v3', credentials=creds)
        print("Serviço do Google Drive autenticado e construído com sucesso no Colab.")
        return service
    except Exception as e:
        print(f'Um erro ocorreu durante a autenticação/construção do serviço no Colab: {e}')
        # Para ver o traceback completo no Colab, você pode re-lançar o erro se desejar
        # raise
        return None

def upload_file_to_folder(service, local_file_path, folder_id, drive_filename=None):
    """Faz upload de um arquivo para uma pasta específica no Google Drive.
    Args:
        service: Objeto de serviço da API do Google Drive autorizado.
        local_file_path: Caminho para o arquivo local a ser enviado.
        folder_id: ID da pasta do Google Drive onde o arquivo será salvo.
        drive_filename: Nome que o arquivo terá no Google Drive (opcional, usa o nome local se None).
    Returns:
        ID do arquivo criado no Drive, ou None se falhar.
    """
    if not os.path.exists(local_file_path):
        print(f"Arquivo local não encontrado: {local_file_path}")
        return None

    if drive_filename is None:
        drive_filename = os.path.basename(local_file_path)

    mimetype, _ = mimetypes.guess_type(local_file_path)
    if mimetype is None:
        mimetype = 'application/octet-stream'

    file_metadata = {
        'name': drive_filename,
        'parents': [folder_id]
    }
    media = MediaFileUpload(local_file_path,
                            mimetype=mimetype,
                            resumable=True)
    try:
        file = service.files().create(body=file_metadata,
                                      media_body=media,
                                      fields='id, name, webViewLink').execute()
        print(f"Arquivo '{file.get('name')}' enviado com sucesso!")
        print(f"ID do Arquivo: {file.get('id')}")
        print(f"Link do Arquivo: {file.get('webViewLink')}")
        return file.get('id')
    except HttpError as error:
        print(f'Um erro ocorreu durante o upload: {error}')
        return None

# --- Seu código principal adaptado ---
if __name__ == '__main__': # No Colab, você pode executar este bloco diretamente em uma célula
    # --- CONFIGURAÇÕES ---
    TARGET_FOLDER_ID = '1qpEBWglQbUH2m6Gh1R8_AfwNnztxVYDi'

    # Supondo que 'files_folder' seja uma variável definida anteriormente no seu notebook Colab
    # contendo o caminho para a pasta local com os arquivos a serem enviados.
    # Exemplo: files_folder = '/content/minha_pasta_de_arquivos'
    # Crie esta pasta e alguns arquivos de exemplo no Colab para testar:
    files_folder = '/content/arquivos_para_upload'
    os.makedirs(files_folder, exist_ok=True)
    # with open(os.path.join(files_folder, 'teste1.txt'), 'w') as f:
    #     f.write('Conteudo do arquivo de teste 1 para Colab.')
    # with open(os.path.join(files_folder, 'teste2.png'), 'wb') as f: # Exemplo com binário
    #    f.write(os.urandom(1024)) # Cria um arquivo png "falso" de 1KB
    # --- FIM DAS CONFIGURAÇÕES DO EXEMPLO ---


    print("Iniciando processo de upload para o Google Drive via Colab...")
    # Use a função de serviço adaptada para o Colab
    drive_service = get_drive_service_colab()

    if drive_service:
        print(f"\nTentando fazer upload de arquivos da pasta '{files_folder}' para a pasta Drive ID '{TARGET_FOLDER_ID}'...")
        arquivos_enviados = 0
        arquivos_falhados = 0
        for root, dirs, files in os.walk(files_folder):
            for file_name in files: # Renomeado 'file' para 'file_name' para evitar conflito
                file_path = os.path.join(root, file_name)
                print(f"Processando arquivo: {file_path}")
                if upload_file_to_folder(drive_service, file_path, TARGET_FOLDER_ID, drive_filename=file_name):
                    arquivos_enviados += 1
                else:
                    arquivos_falhados += 1
        print(f"\nConcluído. Arquivos enviados: {arquivos_enviados}, Falhas: {arquivos_falhados}")
    else:
        print("Não foi possível obter o serviço do Google Drive. Upload cancelado.")